/**
 * ChittyCharge - Authorization Hold Service
 *
 * Part of the ChittyPay ecosystem for ChittyOS.
 * Handles authorization holds (temporary card holds) using Stripe PaymentIntents.
 *
 * Future evolution: Full ChittyPay integration with Mercury Bank for instant payouts,
 * call sign based payments, and cross-border wallet support.
 */

import Stripe from "stripe";

export interface Env {
  STRIPE_SECRET_KEY: string;
  STRIPE_WEBHOOK_SECRET: string;
  CHITTY_ID_TOKEN: string;
  HOLDS: KVNamespace; // KV storage for hold tracking
  ALLOWED_ORIGINS?: string; // Comma-separated list of allowed origins
  CURRENCY?: string;
  DEFAULT_HOLD_AMOUNT_CENTS?: string;
}

// Rate limiting state (simple in-memory for single worker)
const rateLimitStore = new Map<string, { count: number; resetAt: number }>();
const RATE_LIMIT_REQUESTS = 10;
const RATE_LIMIT_WINDOW_MS = 60000; // 1 minute

// Tiered hold limits (product-chief recommendation)
const HOLD_LIMITS = {
  NEW_GUEST: 250000, // $2,500 - First booking
  VERIFIED_GUEST: 500000, // $5,000 - 3+ bookings, no incidents
  PREMIUM_PROPERTY: 1000000, // $10,000 - High-value properties (>$500/night)
} as const;

interface HoldMetadata {
  id: string;
  amount: number;
  currency: string;
  property_id?: string;
  tenant_id?: string;
  customer_email?: string;
  status: string;
  created_at: string;
  expires_at?: string;
}

// Stripe client initialization (per-request)
function getStripeClient(env: Env): Stripe {
  return new Stripe(env.STRIPE_SECRET_KEY, {
    apiVersion: "2025-02-24.acacia",
  });
}

// ChittyID minting (NEVER generate locally - always use id.chitty.cc)
async function mintChittyID(
  env: Env,
  entityType: string = "AUTH",
  metadata: Record<string, any> = {},
): Promise<string> {
  try {
    const response = await fetch("https://id.chitty.cc/v1/mint", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${env.CHITTY_ID_TOKEN}`,
      },
      body: JSON.stringify({
        entity_type: entityType,
        metadata,
      }),
    });

    if (!response.ok) {
      throw new Error(`ChittyID mint failed: ${response.statusText}`);
    }

    const data = await response.json<any>();
    return data.chitty_id || `CHITTY-${entityType}-FALLBACK`;
  } catch (error) {
    console.error("ChittyID minting error:", error);
    // Fallback: Use temporary ID until service is available
    return `CHITTY-${entityType}-PENDING-${Date.now()}`;
  }
}

export default {
  async fetch(
    request: Request,
    env: Env,
    ctx: ExecutionContext,
  ): Promise<Response> {
    const url = new URL(request.url);

    // CORS headers with configurable origin
    const allowedOrigins = env.ALLOWED_ORIGINS
      ? env.ALLOWED_ORIGINS.split(",").map((o) => o.trim())
      : ["https://chitty.cc", "https://*.chitty.cc"];

    const origin = request.headers.get("Origin") || "";
    const allowOrigin = allowedOrigins.some((allowed) => {
      if (allowed === "*") return true;
      if (allowed.includes("*")) {
        const pattern = allowed.replace(/\*/g, ".*");
        return new RegExp(`^${pattern}$`).test(origin);
      }
      return allowed === origin;
    })
      ? origin
      : allowedOrigins[0];

    const corsHeaders = {
      "Access-Control-Allow-Origin": allowOrigin,
      "Access-Control-Allow-Methods": "GET, POST, OPTIONS",
      "Access-Control-Allow-Headers": "Content-Type, ChittyID-Token",
    };

    // Handle CORS preflight
    if (request.method === "OPTIONS") {
      return new Response(null, { headers: corsHeaders });
    }

    // Health check
    if (url.pathname === "/health") {
      return Response.json(
        {
          status: "healthy",
          service: "chittycharge",
          version: "1.0.0",
          stripe_connected: !!env.STRIPE_SECRET_KEY,
          chittyid_connected: !!env.CHITTY_ID_TOKEN,
        },
        { headers: corsHeaders },
      );
    }

    // Stripe webhook handler
    if (url.pathname === "/webhook" && request.method === "POST") {
      return handleWebhook(request, env);
    }

    // API routes require ChittyID token authentication
    const chittyIdToken = request.headers.get("ChittyID-Token");
    if (!chittyIdToken || chittyIdToken !== env.CHITTY_ID_TOKEN) {
      return Response.json(
        { error: "Unauthorized" },
        { status: 401, headers: corsHeaders },
      );
    }

    // Rate limiting (10 requests per minute per token)
    const rateLimitKey = chittyIdToken;
    const now = Date.now();
    const rateLimitEntry = rateLimitStore.get(rateLimitKey);

    if (rateLimitEntry && now < rateLimitEntry.resetAt) {
      if (rateLimitEntry.count >= RATE_LIMIT_REQUESTS) {
        return Response.json(
          {
            error: "Rate limit exceeded",
            details: "Maximum 10 requests per minute. Please try again later.",
          },
          {
            status: 429,
            headers: {
              ...corsHeaders,
              "Retry-After": Math.ceil(
                (rateLimitEntry.resetAt - now) / 1000,
              ).toString(),
            },
          },
        );
      }
      rateLimitEntry.count++;
    } else {
      rateLimitStore.set(rateLimitKey, {
        count: 1,
        resetAt: now + RATE_LIMIT_WINDOW_MS,
      });
    }

    // Cleanup old entries (simple memory management)
    for (const [key, entry] of rateLimitStore.entries()) {
      if (now >= entry.resetAt) {
        rateLimitStore.delete(key);
      }
    }

    try {
      // Route handlers
      if (url.pathname === "/api/holds" && request.method === "POST") {
        return await createHold(request, env, corsHeaders);
      }

      if (url.pathname.startsWith("/api/holds/") && request.method === "GET") {
        const holdId = url.pathname.split("/")[3];
        return await getHoldStatus(holdId, env, corsHeaders);
      }

      if (url.pathname.endsWith("/capture") && request.method === "POST") {
        const holdId = url.pathname.split("/")[3];
        return await captureHold(holdId, request, env, corsHeaders);
      }

      if (url.pathname.endsWith("/cancel") && request.method === "POST") {
        const holdId = url.pathname.split("/")[3];
        return await cancelHold(holdId, env, corsHeaders);
      }

      return Response.json(
        { error: "Not found" },
        { status: 404, headers: corsHeaders },
      );
    } catch (error) {
      console.error("ChittyCharge error:", error);
      const errorMessage =
        error instanceof Error ? error.message : "Internal server error";
      return Response.json(
        { error: errorMessage },
        { status: 500, headers: corsHeaders },
      );
    }
  },
};

/**
 * Create authorization hold
 * POST /api/holds
 */
async function createHold(
  request: Request,
  env: Env,
  corsHeaders: Record<string, string>,
): Promise<Response> {
  const body = await request.json<any>();
  const {
    amount,
    currency = env.CURRENCY || "usd",
    customer_email,
    property_id,
    tenant_id,
    description,
    metadata = {},
  } = body;

  if (!amount || !description) {
    return Response.json(
      { error: "Missing required fields: amount, description" },
      { status: 400, headers: corsHeaders },
    );
  }

  // Validate amount
  if (amount < 50) {
    return Response.json(
      { error: "Amount must be at least $0.50 USD (50 cents)" },
      { status: 400, headers: corsHeaders },
    );
  }

  // Apply tiered hold limits (product-chief recommendation)
  const guestTier = metadata.guest_tier || "NEW_GUEST";
  const maxAmount =
    HOLD_LIMITS[guestTier as keyof typeof HOLD_LIMITS] || HOLD_LIMITS.NEW_GUEST;

  if (amount > maxAmount) {
    const tierLimits = {
      NEW_GUEST: "$2,500",
      VERIFIED_GUEST: "$5,000",
      PREMIUM_PROPERTY: "$10,000",
    };
    return Response.json(
      {
        error: `Amount exceeds limit for ${guestTier} tier`,
        details: `Maximum hold: ${tierLimits[guestTier as keyof typeof tierLimits] || "$2,500"}. Contact support to upgrade tier.`,
        current_tier: guestTier,
        max_amount: maxAmount,
      },
      { status: 400, headers: corsHeaders },
    );
  }

  const stripe = getStripeClient(env);

  const paymentIntentParams: Stripe.PaymentIntentCreateParams = {
    amount,
    currency,
    capture_method: "manual", // This makes it an authorization hold
    description,
    metadata: {
      ...metadata,
      property_id: property_id || "",
      tenant_id: tenant_id || "",
      source: "chittycharge",
      service: "chittypay",
    },
  };

  if (customer_email) {
    paymentIntentParams.receipt_email = customer_email;
  }

  const paymentIntent = await stripe.paymentIntents.create(paymentIntentParams);

  // Mint ChittyID for this authorization hold (NEVER local generation)
  const chittyId = await mintChittyID(env, "AUTH", {
    stripe_payment_intent_id: paymentIntent.id,
    amount: paymentIntent.amount,
    property_id,
    tenant_id,
    source: "chittycharge",
  });

  // Store hold metadata in KV for tracking
  const holdMetadata: HoldMetadata = {
    id: paymentIntent.id,
    amount: paymentIntent.amount,
    currency: paymentIntent.currency,
    property_id,
    tenant_id,
    customer_email,
    status: paymentIntent.status,
    created_at: new Date(paymentIntent.created * 1000).toISOString(),
  };

  // Store with 30-day TTL (max hold duration)
  await env.HOLDS.put(paymentIntent.id, JSON.stringify(holdMetadata), {
    expirationTtl: 2592000, // 30 days in seconds
  });

  // Also index by ChittyID
  await env.HOLDS.put(`chittyid:${chittyId}`, paymentIntent.id, {
    expirationTtl: 2592000,
  });

  return Response.json(
    {
      id: paymentIntent.id,
      chitty_id: chittyId,
      client_secret: paymentIntent.client_secret,
      status: paymentIntent.status,
      amount: paymentIntent.amount,
      amount_capturable: paymentIntent.amount_capturable || 0,
      currency: paymentIntent.currency,
      created_at: new Date(paymentIntent.created * 1000).toISOString(),
      tier: guestTier,
      tier_limit: maxAmount,
      // Note: Authorization hold expiration varies by card network (5-31 days)
      // Check payment method details or Stripe Dashboard for exact expiration
    },
    { status: 201, headers: corsHeaders },
  );
}

/**
 * Get hold status
 * GET /api/holds/:id
 */
async function getHoldStatus(
  holdId: string,
  env: Env,
  corsHeaders: Record<string, string>,
): Promise<Response> {
  const stripe = getStripeClient(env);
  const paymentIntent = await stripe.paymentIntents.retrieve(holdId);

  return Response.json(
    {
      id: paymentIntent.id,
      status: paymentIntent.status,
      amount: paymentIntent.amount,
      amount_capturable: paymentIntent.amount_capturable || 0,
      amount_received: paymentIntent.amount_received || 0,
      currency: paymentIntent.currency,
      created_at: new Date(paymentIntent.created * 1000).toISOString(),
      // Note: Authorization hold expiration varies by card network (5-31 days)
      // Check payment method details or Stripe Dashboard for exact expiration
    },
    { headers: corsHeaders },
  );
}

// Track capture attempts to prevent duplicate captures with different amounts
const captureAttempts = new Map<
  string,
  { amount: number | null; timestamp: number }
>();

/**
 * Capture hold (full or partial)
 * POST /api/holds/:id/capture
 */
async function captureHold(
  holdId: string,
  request: Request,
  env: Env,
  corsHeaders: Record<string, string>,
): Promise<Response> {
  const body = await request.json<any>();
  const { amount_to_capture } = body;

  const stripe = getStripeClient(env);

  // Enhanced idempotency: prevent duplicate captures with different amounts
  const captureKey = `${holdId}`;
  const existingAttempt = captureAttempts.get(captureKey);
  const now = Date.now();

  if (existingAttempt) {
    // Check if attempting same capture within 5 minutes
    if (now - existingAttempt.timestamp < 300000) {
      // If amount differs, reject as duplicate with different amount
      if (existingAttempt.amount !== (amount_to_capture || null)) {
        return Response.json(
          {
            error: "Duplicate capture detected",
            details:
              "This hold has already been captured or a capture is in progress with a different amount.",
          },
          { status: 409, headers: corsHeaders },
        );
      }
    } else {
      // Cleanup old attempt
      captureAttempts.delete(captureKey);
    }
  }

  // Record this capture attempt
  captureAttempts.set(captureKey, {
    amount: amount_to_capture || null,
    timestamp: now,
  });

  const captureParams: Stripe.PaymentIntentCaptureParams = {};
  if (amount_to_capture) {
    captureParams.amount_to_capture = amount_to_capture;
  }

  // Idempotency key includes timestamp for better uniqueness
  const idempotencyKey = `capture-${holdId}-${amount_to_capture || "full"}-${Math.floor(now / 60000)}`;

  const paymentIntent = await stripe.paymentIntents.capture(
    holdId,
    captureParams,
    {
      idempotencyKey,
    },
  );

  // Note: Estimated processing fee - actual fee varies by:
  // - Card type (debit/credit/corporate/international)
  // - Transaction volume tier
  // - International vs domestic cards
  // Check Stripe Dashboard for exact fees
  const estimatedProcessingFee = Math.round(
    (paymentIntent.amount_received || 0) * 0.029 + 30,
  );

  return Response.json(
    {
      id: paymentIntent.id,
      status: paymentIntent.status,
      amount_captured: paymentIntent.amount_received || 0,
      amount_remaining:
        (paymentIntent.amount || 0) - (paymentIntent.amount_received || 0),
      estimated_processing_fee: estimatedProcessingFee,
      processing_fee_note:
        "Estimated based on standard rates. Actual fees vary by card type and volume. Check Stripe Dashboard for exact amounts.",
      captured_at: new Date().toISOString(),
    },
    { headers: corsHeaders },
  );
}

/**
 * Cancel hold (release)
 * POST /api/holds/:id/cancel
 */
async function cancelHold(
  holdId: string,
  env: Env,
  corsHeaders: Record<string, string>,
): Promise<Response> {
  const stripe = getStripeClient(env);
  const paymentIntent = await stripe.paymentIntents.cancel(holdId);

  return Response.json(
    {
      id: paymentIntent.id,
      status: paymentIntent.status,
      canceled_at: new Date().toISOString(),
    },
    { headers: corsHeaders },
  );
}

/**
 * Stripe webhook handler
 * POST /webhook
 */
async function handleWebhook(request: Request, env: Env): Promise<Response> {
  const signature = request.headers.get("stripe-signature");
  if (!signature) {
    return Response.json(
      { error: "Missing stripe-signature header" },
      { status: 400 },
    );
  }

  const body = await request.text();
  const stripe = getStripeClient(env);

  try {
    const event = stripe.webhooks.constructEvent(
      body,
      signature,
      env.STRIPE_WEBHOOK_SECRET,
    );

    console.log("Webhook received:", event.type);

    // Handle specific events
    switch (event.type) {
      case "payment_intent.amount_capturable_updated":
        console.log("Authorization hold authorized:", event.data.object.id);
        break;

      case "charge.captured":
        console.log("Authorization hold captured:", event.data.object.id);
        break;

      case "payment_intent.canceled":
        console.log("Authorization hold released:", event.data.object.id);
        break;

      default:
        console.log("Unhandled event type:", event.type);
    }

    return Response.json({ received: true }, { status: 200 });
  } catch (error) {
    console.error("Webhook error:", error);
    const errorMessage =
      error instanceof Error ? error.message : "Webhook verification failed";
    return Response.json({ error: errorMessage }, { status: 400 });
  }
}
